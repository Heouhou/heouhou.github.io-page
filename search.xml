<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringMVC之请求参数的获取方式]]></title>
    <url>%2F2019%2F05%2F15%2Fspringmvc-zhi-qing-qiu-can-shu-de-huo-qu-fang-shi%2F</url>
    <content type="text"><![CDATA[原文链接 SpringMVC之请求参数的获取方式I. GET请求参数获取get请求参数，一般都是直接挂在请求的url上，所以获取这些参数还是比较简单的 1. 通过 HttpServletRequest获取参数这个可以说是最基本最常见的的方式了， javax.servlet.ServletRequest#getParameter来获取对应的参数 1234567891011@RestController@RequestMapping(path = "webs/demo")public class DemoController &#123; @RequestMapping(path = "req1") public String req1(HttpServletRequest request) &#123; String user = request.getParameter("user"); String password = request.getParameter("password"); return "req1 user: " + user + " pwd: " + password; &#125;&#125; 123456根据上面暴露的接口，我们测试的case就很简单了http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog&amp;password=123456## 输出 req1 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog## 输出 req1 user: 小灰灰Blog pwd: null 说明: 这是一个最基本的获取参数的方式，get，post请求都适用的，通常在filter,intercepter中也是可以通过HttpServletRequest对象来获取请求参数 除了获取常见的请求参数之外，HttpServletRequest可以获取请求头的完整信息 在一次请求的生命周期内，可以通过下面的方式获取Request对象(当然也可以获取response对象) 12HttpServletRequest httpServletRequest = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); 2. 直接方法参数获取1234@RequestMapping(path = "req2")public String req2(String user, String password) &#123; return "req2 user: " + user + " pwd: " + password;&#125; 123456789请求验证http://127.0.0.1:8080/webs/demo/req2?user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog&amp;password=123456## 输出： req2 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456## 输出： req2 user: null pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;User=blog## 输出： req2 user: null pwd: 123456 注意: 上面这种使用方式，相当于直接将url参数映射到了Controller方法的参数上了 方法参数名必须和url参数名完全一致（区分大小写） 顺序无关 若参数没传，则默认为null 一个疑问 上面的demo中Controller的方法参数都是String还好，如果将password改成int，会出现什么情况 1234@RequestMapping(path = "req2")public String req2(String user, int password) &#123; return "req2 user: " + user + " pwd: " + password;&#125; 实际测试 12345678910111213# case1 http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;user=blog## 输出： req2 user: blog pwd: 123456# case 2http://127.0.0.1:8080/webs/demo/req2?password2=123456&amp;user=blog## 输出: 报错, Optional int parameter 'password' is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type# case 3http://127.0.0.1:8080/webs/demo/req2?password=abc&amp;user=blog## 输出：报错, "Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: "abc"" 说明: 如果请求参数与方法参数类型不一致，会抛出转换异常 如果方法参数为非封装基本类型，则url参数必须存在，否则报错 3. RequestParam注解方式获取请求参数通过@RequestParam注解获取参数的方式和上面的一种比较类似 12345@RequestMapping(path = "req3", method = RequestMethod.GET)public String req3(@RequestParam("user") String username, @RequestParam("password") String pwd) &#123; return "req3 user: " + username + " pwd: " + pwd;&#125; 12345678# case1 http://127.0.0.1:8080/webs/demo/req3?password=123456&amp;user=blog## 输出: req3 user: blog pwd: 123456# case2http://127.0.0.1:8080/webs/demo/req3?password=123456## 输出：报错， Required String parameter 'user' is not presen 说明: 不指定注解的name或value属性时，等同于第二种使用姿势 注解的name属性或value属性，用实际的参数名来指定 controller的参数名与url参数名没有强关联（区别第二种方式） 参数类型需要保证一致（通第二种方式） 如果url参数可选，请设置require属性为false，如下 1@RequestParam(name = "user", required = false) String username 4. Bean方式获取参数对于请求参数比较复杂的情况下，我比较喜欢这种使用姿势，管理起来方便简单 12345678910@Datapublic static class UserDO &#123; String user; String password;&#125;@RequestMapping(path = "req4", method = RequestMethod.GET)public String req4(UserDO userDO) &#123; return "req4 userDO: " + userDO;&#125; 测试case 123456# case1http://127.0.0.1:8080/webs/demo/req4?password=123456&amp;user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog## 输出: req4 userDO: DemoController.UserDO(user=小灰灰Blog, password=123456)# case2http://127.0.0.1:8080/webs/demo/req4?password=123456## 输出: req4 userDO: DemoController.UserDO(user=null, password=123456) 说明: 定义一个bean，内部属性和请求参数对应 允许参数不存在的情况，会使用null代替（所以，尽量不要使用非封装基本类型，否则参数不传时，会抛异常） bean的属性，可以根据实际情况指定类型 5. ModelAttribute注解方式@ModelAttribute注解的方法，会优于Controller之前执行，一般更常见于向视图传输数据使用，此处不详细展开，正常来讲，专门的获取参数不太会用这这种方式来玩 6. Path参数Path参数，专指的是请求路径的参数，如 1234567http://127.0.0.1:8080/webs/demo/req4?password=123456上面这个url中，password是我们传统意义上的请求参数，其中path参数则是指其中 req4, demo这种path路径中的一环；对此，最常见的一个case就是常见的博客中,如开源中国的一个博客链接https://my.oschina.net/u/566591/blog/1601400566591 : 这个参数主要用来区分用户1601400 : 这个参数则主要是表示对应的博文一般path参数的获取方式如下 1234@RequestMapping(path = "req6/&#123;user&#125;/info")public String req6(@PathVariable(name = "user") String user) &#123; return "req6 user: " + user;&#125; 测试case 1234567891011# case1 http://127.0.0.1:8080/webs/demo/req6/blog/info?user=haha## 输出：req6 user: blog# case2http://127.0.0.1:8080/webs/demo/req6/blog?user=haha## 输出: 404# case3http://127.0.0.1:8080/webs/demo/req6/info?user=haha## 输出: 404 注意: path参数的使用，需要确保参数存在且类型匹配 path参数和url参数不会相互影响 II. POST请求参数获取POST请求参数，更多的是看提交表单参数是否可以获取到，以及如何获取，主要的手段依然是上面几种方式，下面验证下是否ok 1. HttpServletRequest方式获取参数测试case，可以借助curl来实现post请求 1234567891011# case1 curl -d "user=小灰灰Blog&amp;password=123456" "http://127.0.0.1:8080/webs/demo/req1"## 输出： req1 user: 小灰灰Blog pwd: 123456# case2curl -d "user=小灰灰Blog" "http://127.0.0.1:8080/webs/demo/req1?password=123456"## 输出：req1 user: 小灰灰Blog pwd: 12345# case3curl -d "user=小灰灰Blog" "http://127.0.0.1:8080/webs/demo/req1?user=greyBlog"## 输出：req1 user: greyBlog pwd: null curl也可以换成js请求测试方式 1234567891011var formData = new FormData();formData.append("user", "小灰灰Blog");$.ajax(&#123; url: 'http://127.0.0.1:8080/webs/demo/req1?password=123456', type: 'post', cache: false, data: formData, processData: false, contentType: false&#125;); 说明: 对于HttpServletReuqest方式获取参数时，get和post没什么区别 若url参数和表单参数同名了，测试结果显示使用的是url参数（待确认，当然最好不要这么干）2. 方法参数获取几个测试demo如下 123456789101112# case 1curl -d "user=小灰灰Blog&amp;password=123456" "http://127.0.0.1:8080/webs/demo/req2"## 输出： req2 user: 小灰灰Blog pwd: 123456# case 2curl -d "password=123456" "http://127.0.0.1:8080/webs/demo/req2"## 输出：req2 user: null pwd: 123456# case 3curl -d "password=123456" "http://127.0.0.1:8080/webs/demo/req2?user=blog"## 输出： req2 user: blog pwd: 123456基本上使用姿势和get没什么区别 3. RequestParam注解方式1234567891011# case 1curl -d "password=123456&amp;user=blog" "http://127.0.0.1:8080/webs/demo/req3"## 输出： req3 user: blog pwd: 123456# case 2curl -d "password=123456" "http://127.0.0.1:8080/webs/demo/req3?user=blog"## 输出： req3 user: blog pwd: 123456# case 3curl -d "password=123456&amp;user=blog" "http://127.0.0.1:8080/webs/demo/req3?password=900"## 输出：req3 user: blog pwd: 900,123456 注意: 和前面的两种方式不同的是，当post表单的参数和url参数同名时，会合并成一个字符串4. Bean方式123456789101112## case1 curl -d "password=123456&amp;user=blog" "http://127.0.0.1:8080/webs/demo/req4?password=900"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=900,123456)## case2curl -d "password=123456&amp;user=blog" "http://127.0.0.1:8080/webs/demo/req4"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=123456)## case3curl -d "password=123456" "http://127.0.0.1:8080/webs/demo/req4"## 输出 req4 userDO: DemoController.UserDO(user=null, password=123456)这种方式不区分get,post，所以完全复杂的交互接口，完全可以考虑用bean的方式来定义请求参数 5. PathVariable这个没法玩… III. 多媒体上传参数获取上传文件的支持，对于传统的spring-mvc来说，可能需要一些添加一些相关配置，不在本文的范畴内，下面默认已经配置好 1. 实例支持1234567891011121314@RequestMapping(path = &#123;"wx/upload", "wx/wx/upload"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)@ResponseBodypublic String upload(HttpServletRequest request) &#123; MultipartFile file = null; if (request instanceof MultipartHttpServletRequest) &#123; file = ((MultipartHttpServletRequest) request).getFile("image"); &#125; if (file == null) &#123; throw new IllegalArgumentException("图片不能为空!"); &#125; return "success";&#125; 简单来说，主要是利用HttpServletRequest来获取上传的文件 注意: 如果接口必须要求上传文件，可以直接把参数声明为 MultipartHttpServletRequest， 此时调用方如果不传参数，会被异常拦截（可以通过@ControllerAdvice来拦截全局异常） 如果可以不上传文件，则可以用上面的这种猥琐姿势，内部进行判断 ((MultipartHttpServletRequest) request).getFile(xxx)来获取指定名的上传文件IV. 小结1. 五种获取参数的姿势 方式 | 注意事项| :——– | :——–|HttpServletRequest获取参数 | 最常见通用方法参数与请求参数同名 | 注意参数名统一，注意类型一致，尽量不用非包装基本类型@RequestParam注解 | 同上，可注解内指定http参数名Bean方式| 定义一个bean，会将同名的http参数赋值进去，推荐@PathVariable 注解 | 请求url参数 2. 传文件使用姿势 使用MultipartHttpServletRequest来获取上传的文件，当然也可以获取基本的请求参数]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 注解 @RequestParam 的使用]]></title>
    <url>%2F2019%2F05%2F14%2Frequestparam-de-shi-yong%2F</url>
    <content type="text"><![CDATA[@RequestParam 参数加与不加的区别123456789@RequestMapping("/list")public String test(int userId) &#123; return "list";&#125; @RequestMapping("/list")public String test(@RequestParam int userId) &#123; return "list";&#125; 第一种写法参数为非必传，第二种写法参数为必传。参数名为userId。 第二种写法可以通过@RequestParam(required = false)设置为非必传。因为required值默认是true，所以默认必传。 第二种写法可以通过@RequestParam(“userId”)或者@RequestParam(value = “userId”)指定参数名。 第二种写法可以通过@RequestParam(defaultValue = “0”)指定参数默认值 当@RequestParam(required = false) 或不加 @RequestParam时, 参数类型为int,该参数不传,会报错,因为如果不传,会把null 复制到int,会报错. 推荐使用包装类Integer]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot Value 注解注入static 字段]]></title>
    <url>%2F2019%2F05%2F14%2Fspringboot-value-zhu-jie-zhu-ru-static-zi-duan%2F</url>
    <content type="text"><![CDATA[普通参数使用@Value 示例:123456789public class Utils &#123; @Value("$&#123;test.host&#125;") private String host; @Value("$&#123;test.port&#125;") private String port; ......&#125; 但是在注入static字段时,直接使用 @Value 为静态变量赋值是不行的，可以使用 set 方法：123456789101112131415161718@Componentpublic class Utils &#123; private static String host; @Value("$&#123;test.host&#125;") public void setHost(String host) &#123; Utils.host = host; &#125; private static String port; @Value("$&#123;test.port&#125;") public void setPort(String port) &#123; Utils.port = port; &#125; ......&#125; 注意，需要使用 @Component 注解。]]></content>
      <categories>
        <category>java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ 入门]]></title>
    <url>%2F2019%2F05%2F08%2Factivemq-ru-men%2F</url>
    <content type="text"><![CDATA[介绍MQ是消息中间件，是一种在分布式系统中应用程序借以传递消息的媒介，常用的有ActiveMQ，RabbitMQ，kafka。ActiveMQ是Apache下的开源项目，完全支持JMS1.1和J2EE1.4规范的JMS Provider实现。 特点： 支持多种语言编写客户端 对spring的支持，很容易和spring整合 支持多种传输协议：TCP,SSL,NIO,UDP等 支持AJAX 消息形式： 点对点（queue） 一对多（topic） 安装 参考链接 下载apache-activemq-5.13.1-bin.tar.gz 下载地址：http://download.csdn.net/download/u014223912/9464747 下载后解压 进入到/apache-activemq-5.13.1/bin/macosx目录 启动ActiveMQ 1./activemq start 在浏览器中 http://127.0.0.1:8161/admin/ 默认用户名密码都为admin 参考资料https://blog.csdn.net/jiuqiyuliang/article/category/5617711]]></content>
      <categories>
        <category>java</category>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 安装 Mysql]]></title>
    <url>%2F2019%2F04%2F29%2Fmac-an-zhuang-mysql%2F</url>
    <content type="text"><![CDATA[### https://www.jianshu.com/p/4cb5ef29a099]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>brew</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git SSH 和 HTTP 的区别]]></title>
    <url>%2F2019%2F04%2F24%2Fgit-ssh-he-http-de-qu-bie%2F</url>
    <content type="text"><![CDATA[最近项目迁移到git上去,在提交代码时遇到了要每次输入账号密码的情况,查看资料时了解到了 http 和ssh 的问题,特此记录.百度了一下,大部分的回答如下: HTTP使用 http url 克隆对初学者来说会比较方便，复制 http url 然后到命令行里面直接用 git clone 命令克隆到本地就好了，在执行 clone 命令之后需要输入你的 GitLab 的帐号和密码。使用 git Bash 每次都需要输入帐号和密码，不过在使用 PhpStorm 时，PhpStorm 会记住你的用户名和密码，只需第一次使用时输入就好。 SSH使用 SSH url 克隆却需要在克隆之前先配置和添加好 SSH key ，因此，如果你想要使用 SSH url 克隆的话，你必须是这个项目的拥有者。否则你是无法添加 SSH key 的，另外 ssh 默认是每次 fetch 和 push 代码都不需要输入账号和密码。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sourceTree 每次提交代码都要输入账号密码]]></title>
    <url>%2F2019%2F04%2F24%2Fsourcetree-mei-ci-ti-jiao-dai-ma-du-yao-shu-ru-zhang-hao-mi-ma%2F</url>
    <content type="text"><![CDATA[方法一: 使用ssh 方式做免密处理 如果必须使用http 的方式 方法二:在.git目录中有个config目录，在路径前配置下用户名和密码即可，如下所示：12345678910111213[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;origin&quot;] url = http://账号:&apos;密码&apos;@192.168.10.7:8090/test/Django.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master 方法三:设置对所有项目有效git config –global credential.helper osxkeychain #第一次需要输入密码，以后都不需要了]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>sourceTree</tag>
      </tags>
  </entry>
</search>
